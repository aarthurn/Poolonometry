<!DOCTYPE html>
<!-- 
  Enhanced Pool Game Physics - Updated 2025-05-14 19:03:37 UTC
  Changes by GitHub Copilot:
  - Improved rolling physics for more realistic ball movement
  - More granular friction control with value display
  - Disabled shooting during ball motion
  - Cue ball return functionality
  - Added missing exact trig values (1/√3, √3)
  - Original game by aarthurn
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Trig Pool Game</title>
  <style>
    body { margin: 0; font-family: sans-serif; background: #222; color: #eee; }
    #menu, #controls, #solutionOverlay, #errorOverlay {
      position: absolute; width: 100%; text-align: center;
    }
    #menu { top: 10px; z-index: 3; }
    #controls {
      top: 50px; left: 50%; transform: translateX(-50%);
      z-index: 3; background: rgba(0,0,0,0.5);
      padding: 10px; border-radius: 8px; display: none;
    }
    #tableContainer {
      width: 800px; height: 400px; margin: 220px auto 0;
      border: 20px solid #8B4513; border-radius: 30px;
      background: #8B4513; position: relative; z-index: 1;
    }
    #tableContainer canvas {
      display: block; margin: 0; background: #0a5;
    }
    #solutionOverlay, #errorOverlay {
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8); display: none;
      color: #fff; z-index: 4;
    }
    #solutionOverlay canvas, #errorOverlay canvas { background: transparent; }
    #solutionText, #errorText {
      position: absolute; top: 20px; left: 20px; text-align: left;
    }
    button { padding: 6px 12px; margin: 6px; }
    button:disabled { opacity: 0.5; }
    .slider-value { 
      display: inline-block; 
      min-width: 60px; 
      font-family: monospace; 
      margin-left: 5px; 
    }
  </style>
</head>
<body>
  <div id="menu">
    <h1>Select Game Type</h1>
    <button onclick="startGame('8-ball')">8-Ball</button>
    <button onclick="startGame('9-ball')">9-Ball</button>
  </div>
  <div id="controls">
    Player: <span id="playerLabel">1</span>
    <select id="unitSelect"><option>Degrees</option><option>Radians</option></select>
    <select id="ratioTypeSelect">
      <option>sin</option><option>cos</option><option>tan</option>
      <option>csc</option><option>sec</option><option>cot</option>
    </select>
    <select id="ratioValueSelect">
      <option value="0" selected>0</option>
      <option value="decimal">Enter decimal...</option>
      <option value="-1.7320508075688772">-√3</option>
      <option value="-1">-1</option>
      <option value="-0.8660254037844386">-√3/2</option>
      <option value="-0.7071067811865475">-√2/2</option>
      <option value="-0.5773502691896257">-1/√3</option>
      <option value="-0.5">-1/2</option>
      <option value="0.5">1/2</option>
      <option value="0.5773502691896257">1/√3</option>
      <option value="0.7071067811865476">√2/2</option>
      <option value="0.8660254037844386">√3/2</option>
      <option value="1">1</option>
      <option value="1.7320508075688772">√3</option>
    </select>
    <input type="number" id="decimalInput" placeholder="Decimal" style="display:none;width:60px;" step="0.01" />
    <select id="quadrantSelect">
      <option value="1">Quadrant I</option>
      <option value="2">Quadrant II</option>
      <option value="3">Quadrant III</option>
      <option value="4">Quadrant IV</option>
    </select>
    <br>
    Power: <input type="range" id="powerSlider" min="1" max="16" step="1" value="5" />
    <span id="powerValue" class="slider-value">5.0</span>
    <br>
    Friction: <input type="range" id="frictionSlider" min="0.001" max="0.025" step="0.001" value="0.01" />
    <span id="frictionValue" class="slider-value">0.010</span>
    <br>
    Min Angle: <select id="minAngleSelect"></select>
    Max Angle: <select id="maxAngleSelect"></select>
    <br>
    <button id="analyzeBtn">Analyze Path</button>
    <button id="shootBtn">Shoot</button>
    <button id="ballInHandBtn" onclick="toggleBallInHandMode()">Ball in Hand</button>
    <button id="toggleAnimationBtn">Animated Solutions: ON</button>
  </div>
  <div id="tableContainer">
    <canvas id="tableCanvas" width="800" height="400"></canvas>
    <div id="solutionOverlay">
      <canvas id="solutionCanvas" width="800" height="400"></canvas>
      <div id="solutionText"></div>
      <button onclick="hideSolution()">Continue</button>
    </div>
  </div>
  <div id="errorOverlay">
    <div id="errorText"></div>
    <button onclick="hideError()">OK</button>
  </div>
  <script>
    let ballInHandMode = false;
    const sidePocketRadius = 16 * 1.3;
    const cornerPocketRadius = sidePocketRadius * 1.3;
    const canvas = document.getElementById('tableCanvas'), ctx = canvas.getContext('2d');
    const solCanvas = document.getElementById('solutionCanvas'), solCtx = solCanvas.getContext('2d');
    let gameType, currentPlayer = 1, balls = [];
    const ballRadius = 10;
    let showGrid = false, showArm = false;
    let armVector = { x: 0, y: 0 };
    let isMoving = false; // Track if any balls are in motion
    let cueBallPocketedDuringShot = false;
    let animatedSolutionsEnabled = true;
    let initialShotData = {};
    let minAngleRange = -360; // Default in degrees
    let maxAngleRange = 360;  // Default in degrees
    let nonCueBallsForSolution = [];
    let cueBallOriginalPositionBeforeHand = null;
    const INITIAL_CUE_X = 100;
    const INITIAL_CUE_Y = 200;
    
    // Physics constants
    const ROLLING_THRESHOLD = 0.5;  // Speed at which rolling friction takes over
    const STATIC_FRICTION_MULTIPLIER = 2.5;  // Increased friction at low speeds
    const MINIMUM_SPEED = 0.01;  // Speed below which balls stop completely

    const pockets = [
      { x: 0, y: 0, r: cornerPocketRadius },
      { x: 400, y: 0, r: sidePocketRadius },
      { x: 800, y: 0, r: cornerPocketRadius },
      { x: 0, y: 400, r: cornerPocketRadius },
      { x: 400, y: 400, r: sidePocketRadius },
      { x: 800, y: 400, r: cornerPocketRadius }
    ];

    const ballColors = {
      1:'#FFFF00',2:'#0000FF',3:'#FF0000',4:'#800080',5:'#FFA500',
      6:'#008000',7:'#800000',8:'#000000',9:'#FFFF00',10:'#0000FF',
      11:'#FF0000',12:'#800080',13:'#FFA500',14:'#008000',15:'#800000'
    };

    // Event Listeners
    const unitSelect = document.getElementById('unitSelect');
    const ratioValueSelect = document.getElementById('ratioValueSelect');
    const decimalInput = document.getElementById('decimalInput');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const minAngleSelect = document.getElementById('minAngleSelect');
    const maxAngleSelect = document.getElementById('maxAngleSelect');

    ratioValueSelect.addEventListener('change', e => {
      decimalInput.style.display = e.target.value === 'decimal' ? 'inline' : 'none';
    });
    analyzeBtn.addEventListener('click', analyzePath);
    document.getElementById('shootBtn').addEventListener('click', () => {
      if (!isMoving) {
        showGrid = false;
        showArm = false;
        handleShoot();
      }
    });
  document.getElementById('toggleAnimationBtn').addEventListener('click', () => {
    animatedSolutionsEnabled = !animatedSolutionsEnabled;
    document.getElementById('toggleAnimationBtn').textContent = `Animated Solutions: ${animatedSolutionsEnabled ? 'ON' : 'OFF'}`;
  });

    // Slider value display updates
    document.getElementById('powerSlider').addEventListener('input', e => {
      document.getElementById('powerValue').textContent = e.target.value;
    });
    document.getElementById('frictionSlider').addEventListener('input', e => {
      document.getElementById('frictionValue').textContent = e.target.value.padStart(5, '0');
    });

    const DEGREE_OPTIONS = [-720, -540, -360, -180, 0, 180, 360, 540, 720];

    function degreesToPiRadians(degrees) {
      if (degrees === 0) return "0";
      const num = degrees / 180;
      if (Number.isInteger(num)) {
        return num === 1 ? "π" : num === -1 ? "-π" : `${num}π`;
      }
      // Simplify fraction for common values like 90 (π/2), 270 (3π/2) etc.
      // For simplicity, we'll stick to integer multiples of π for now.
      // More complex fraction simplification can be added if needed.
      // For this set of values, they are all multiples of 180.
      return `${degrees/180}π`; // Should be simplified if not integer
    }

    function populateAngleDropdown(selectElement, options, selectedValue, isRadians) {
      selectElement.innerHTML = '';
      options.forEach(degValue => {
        const option = document.createElement('option');
        option.value = degValue;
        option.textContent = isRadians ? degreesToPiRadians(degValue) : `${degValue}°`;
        if (degValue === selectedValue) {
          option.selected = true;
        }
        selectElement.appendChild(option);
      });
    }

    function updateAngleRangeDropdowns() {
      const isRadians = unitSelect.value === 'Radians';
      const currentMinVal = parseFloat(minAngleSelect.value || minAngleRange);
      const currentMaxVal = parseFloat(maxAngleSelect.value || maxAngleRange);

      // Filter options for minAngleSelect: all options <= currentMaxVal
      const minOptions = DEGREE_OPTIONS.filter(deg => deg <= currentMaxVal);
      populateAngleDropdown(minAngleSelect, minOptions, currentMinVal, isRadians);
      minAngleRange = parseFloat(minAngleSelect.value);


      // Filter options for maxAngleSelect: all options >= currentMinVal
      const maxOptions = DEGREE_OPTIONS.filter(deg => deg >= currentMinVal);
      populateAngleDropdown(maxAngleSelect, maxOptions, currentMaxVal, isRadians);
      maxAngleRange = parseFloat(maxAngleSelect.value);
    }

    minAngleSelect.addEventListener('change', (e) => {
      minAngleRange = parseFloat(e.target.value);
      updateAngleRangeDropdowns(); // Re-filter max and update display
    });

    maxAngleSelect.addEventListener('change', (e) => {
      maxAngleRange = parseFloat(e.target.value);
      updateAngleRangeDropdowns(); // Re-filter min and update display
    });

    unitSelect.addEventListener('change', updateAngleRangeDropdowns);

    // Initial population
    document.addEventListener('DOMContentLoaded', () => {
        // Set initial values before populating, so filtering works correctly
        minAngleSelect.value = minAngleRange.toString();
        maxAngleSelect.value = maxAngleRange.toString();
        updateAngleRangeDropdowns();
    });

function toggleBallInHandMode() {
  ballInHandMode = !ballInHandMode;
  const cueBall = balls[0];
  if (ballInHandMode) {
    // Entering Ball in Hand mode
    cueBallOriginalPositionBeforeHand = { x: cueBall.x, y: cueBall.y };
    cueBall.x = -1000; // Move cue ball off-screen
    cueBall.y = -1000;
    drawTable(); // Redraw to make cue ball disappear

    document.getElementById('ballInHandBtn').textContent = 'Place Ball';
    document.addEventListener('mousemove', updateCueBallPosition);
    // Defer adding click listener to prevent immediate placement by the button click
    setTimeout(() => {
      // Ensure mode is still active before adding listener
      if (ballInHandMode) {
        document.addEventListener('click', placeCueBall);
      }
    }, 0);
  } else {
    // Exiting Ball in Hand mode (e.g., by clicking "Place Ball" again to cancel)
    document.getElementById('ballInHandBtn').textContent = 'Ball in Hand';
    document.removeEventListener('mousemove', updateCueBallPosition);
    document.removeEventListener('click', placeCueBall); // Ensure this is removed

    if (cueBallOriginalPositionBeforeHand) {
      // Restore cue ball to its original position if placement was cancelled
      cueBall.x = cueBallOriginalPositionBeforeHand.x;
      cueBall.y = cueBallOriginalPositionBeforeHand.y;
      cueBallOriginalPositionBeforeHand = null;
      drawTable(); // Redraw to show restored cue ball
    }
  }
}

function drawBall(ball) {
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
  ctx.fillStyle = ball.color;
  ctx.fill();
}

function updateCueBallPosition(event) {
  const cueBall = balls[0];
  const rect = canvas.getBoundingClientRect();
  cueBall.x = event.clientX - rect.left;
  cueBall.y = event.clientY - rect.top;
  drawTable(); // Redraw the table to show the cue ball moving
}

function placeCueBall(event) {
  const cueBall = balls[0];
  const rect = canvas.getBoundingClientRect();
  cueBall.x = event.clientX - rect.left;
  cueBall.y = event.clientY - rect.top;
  drawTable(); // Redraw table to show final placement
  ballInHandMode = false; // Exiting mode after placement
  document.getElementById('ballInHandBtn').textContent = 'Ball in Hand';
  document.removeEventListener('mousemove', updateCueBallPosition);
  document.removeEventListener('click', placeCueBall);
  cueBallOriginalPositionBeforeHand = null; // Successfully placed, no need to restore
}

    function findClearSpot(x, y) {
      // Spiral search for a clear spot
      let angle = 0;
      let radius = 0;
      const step = Math.PI / 8;
      const radiusStep = ballRadius;
      
      while (radius < canvas.width / 2) {
        const testX = x + radius * Math.cos(angle);
        const testY = y + radius * Math.sin(angle);
        
        // Check if position is valid
        if (testX >= ballRadius && testX <= canvas.width - ballRadius &&
            testY >= ballRadius && testY <= canvas.height - ballRadius) {
          
          // Check for collision with other balls
          let isClear = true;
          for (const ball of balls) {
            if (Math.hypot(ball.x - testX, ball.y - testY) < 2.2 * ballRadius) {
              isClear = false;
              break;
            }
          }
          
          if (isClear) {
            return { x: testX, y: testY };
          }
        }
        
        angle += step;
        if (angle >= 2 * Math.PI) {
          angle = 0;
          radius += radiusStep;
        }
      }
      
      // If no spot found, return initial position
      return { x: INITIAL_CUE_X, y: INITIAL_CUE_Y };
    }

    function computeTheta() {
      const type = document.getElementById('ratioTypeSelect').value;
      const valSel = document.getElementById('ratioValueSelect').value;
      const val = valSel === 'decimal' ? parseFloat(document.getElementById('decimalInput').value) : parseFloat(valSel);
      if (isNaN(val)) return null;
      const quad = parseInt(document.getElementById('quadrantSelect').value, 10);
      const raw = ['csc','sec','cot'].includes(type) ? 1/val : val;
      const absVal = Math.abs(raw);
      let theta = /sin|csc/.test(type) ? Math.asin(absVal)
                 : /cos|sec/.test(type) ? Math.acos(absVal)
                 : Math.atan(absVal);
      switch (quad) {
        case 2: theta = Math.PI - theta; break;
        case 3: theta = Math.PI + theta; break;
        case 4: theta = 2*Math.PI - theta; break;
      }
      return theta;
    }

    function analyzePath() {
      if (isMoving) return;
      const theta = computeTheta();
      if (theta === null) return;
      showGrid = true;
      armVector.x = Math.cos(theta) * 100;
      armVector.y = -Math.sin(theta) * 100;
      showArm = true;
      drawTable();
    }

    function handleShoot() {
      if (isMoving) return;
      cueBallPocketedDuringShot = false; // Reset flag for the new shot
      const theta = computeTheta();
      if (theta === null) return;
    
      // Store initial shot data for solution animation
      const ratioValueSelect = document.getElementById('ratioValueSelect');
      initialShotData = {
        cueX: balls[0].x,
        cueY: balls[0].y,
        ratioType: document.getElementById('ratioTypeSelect').value,
        ratioValueString: ratioValueSelect.value,
        ratioValueNumeric: ratioValueSelect.value === 'decimal' ? parseFloat(document.getElementById('decimalInput').value) : parseFloat(ratioValueSelect.value),
        quadrant: parseInt(document.getElementById('quadrantSelect').value, 10),
        unit: document.getElementById('unitSelect').value,
        actualTheta: theta
      };
    
      // Check if entered options are compatible according to CAST rule
      const sign = initialShotData.ratioValueNumeric >= 0 ? '+' : '-';
      if (Math.abs(initialShotData.ratioValueNumeric) !== 1 && !isCompatible(initialShotData.ratioType, initialShotData.quadrant, sign)) {
        displayMessage("Invalid shot. You lose a turn.");
        return;
      }
    
      const power = parseFloat(document.getElementById('powerSlider').value) * 0.8;
      const friction = parseFloat(document.getElementById('frictionSlider').value);
    
      balls[0].vx = Math.cos(theta) * power;
      balls[0].vy = Math.sin(-theta) * power;
      balls.forEach(b => b.friction = friction);
    
      document.getElementById('shootBtn').disabled = true;
      isMoving = true;
      animateShot();
    }
    
    function isCompatible(ratioType, quadrant, sign) {
      if (ratioType === 'sin' || ratioType === 'csc') {
        return (sign === '+' && (quadrant === 1 || quadrant === 2)) || (sign === '-' && (quadrant === 3 || quadrant === 4));
      } else if (ratioType === 'cos' || ratioType === 'sec') {
        return (sign === '+' && (quadrant === 1 || quadrant === 4)) || (sign === '-' && (quadrant === 2 || quadrant === 3));
      } else if (ratioType === 'tan' || ratioType === 'cot') {
        return (sign === '+' && (quadrant === 1 || quadrant === 3)) || (sign === '-' && (quadrant === 2 || quadrant === 4));
      }
      return false;
    }
    
    // New function to display a message to the player
   function displayMessage(message) {
     const messageElement = document.getElementById('errorOverlay');
     messageElement.style.display = 'block';
     const errorTextElement = document.getElementById('errorText');
     errorTextElement.textContent = message;
     // You may want to add a timeout to clear the message after a few seconds
     setTimeout(() => {
       messageElement.style.display = 'none';
       errorTextElement.textContent = '';
     }, 3000);
   }

    function startGame(type) {
      gameType = type;
      document.getElementById('menu').style.display = 'none';
      document.getElementById('controls').style.display = 'block';
      document.getElementById('playerLabel').textContent = currentPlayer;
      initBalls();
      drawTable();
    }

    function shuffle(arr) { return arr.sort(() => Math.random()-0.5); }

    function initBalls() {
      balls = [{ x:INITIAL_CUE_X, y:INITIAL_CUE_Y, vx:0, vy:0, mass:1, number:0, color:'#fff', friction:0 }];
      const sx = 500, sy = canvas.height/2;
      const pattern = gameType==='8-ball' ? [1,2,3,4,5] : [1,2,3,2,1];
      const nums = shuffle(gameType==='8-ball' ? [1,2,3,4,5,6,7,9,10,11,12,13,14,15] : [1,2,3,4,5,6,7,8]);
      pattern.forEach((cnt,r) => {
        for(let c=0;c<cnt;c++){
          const num = (r===Math.floor(pattern.length/2) && c===1) ? (gameType==='8-ball'?8:9) : nums.shift();
          balls.push({ x:sx + r*2*ballRadius, y:sy+(c-(cnt-1)/2)*2*ballRadius, vx:0, vy:0, mass:1, number:num, isStripe:num>8, color:ballColors[num], friction:0 });
        }
      });
    }

    function drawTable() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#060'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#000'; pockets.forEach(p=>{ctx.beginPath();ctx.arc(p.x,p.y,p.r,0,2*Math.PI);ctx.fill();});
      if (showGrid) drawGrid();
      balls.forEach(drawBall);
      if (showArm) drawArm();
    }

    function drawGrid() {
      const spacing = 25;
      const origin = balls[0];
      ctx.save();
      ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1;
      ctx.font='12px sans-serif'; ctx.fillStyle='#fff';
      for(let x=origin.x % spacing; x<canvas.width; x+=spacing){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
      for(let y=origin.y % spacing; y<canvas.height; y+=spacing){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }
      ctx.strokeStyle='#fff'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(origin.x,0); ctx.lineTo(origin.x,canvas.height); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,origin.y); ctx.lineTo(canvas.width,origin.y); ctx.stroke();
      for(let dx=-Math.floor(origin.x/spacing); dx<Math.ceil((canvas.width-origin.x)/spacing); dx++){
        const xPos = origin.x + dx*spacing;
        ctx.fillText((dx).toString(), xPos+2, origin.y-4);
      }
      for(let dy=-Math.floor(origin.y/spacing); dy<Math.ceil((canvas.height-origin.y)/spacing); dy++){
        const yPos = origin.y + dy*spacing;
        if(dy!==0) ctx.fillText(((-dy)).toString(), origin.x+4, yPos-2);
      }
      ctx.restore();
    }

    function drawArm() {
      const origin = balls[0];
      ctx.save();
      ctx.strokeStyle='#fff'; ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(origin.x, origin.y);
      ctx.lineTo(origin.x + armVector.x, origin.y + armVector.y);
      ctx.stroke();
      const angle = Math.atan2(armVector.y, armVector.x);
      const headLen = 10;
      ctx.beginPath();
      ctx.moveTo(origin.x + armVector.x, origin.y + armVector.y);
      ctx.lineTo(origin.x + armVector.x - headLen * Math.cos(angle - Math.PI/6), origin.y + armVector.y - headLen * Math.sin(angle - Math.PI/6));
      ctx.lineTo(origin.x + armVector.x - headLen * Math.cos(angle + Math.PI/6), origin.y + armVector.y - headLen * Math.sin(angle + Math.PI/6));
      ctx.closePath(); ctx.fillStyle='#fff'; ctx.fill();
      ctx.restore();
    }

    function drawBall(b) {
      ctx.save(); ctx.beginPath(); ctx.arc(b.x,b.y,ballRadius,0,2*Math.PI);
      ctx.fillStyle = b.number===0 ? b.color : (b.isStripe ? '#fff' : b.color);
      ctx.fill();
      if(b.isStripe) {
        ctx.beginPath(); ctx.rect(b.x-ballRadius, b.y-ballRadius/3, 2*ballRadius, 2*ballRadius/3);
        ctx.clip(); ctx.beginPath(); ctx.arc(b.x,b.y,ballRadius,0,2*Math.PI); ctx.fillStyle=b.color; ctx.fill();
      }
      ctx.strokeStyle='#000'; ctx.lineWidth=1; ctx.stroke();
      if(b.number>0) {
        ctx.beginPath(); ctx.arc(b.x,b.y,ballRadius*0.5,0,2*Math.PI);
        ctx.fillStyle='#fff'; ctx.fill(); ctx.fillStyle='#000';
        ctx.font='12px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(b.number,b.x,b.y);
      }
      ctx.restore();
    }

    function collide(b1, b2) {
      const dx = b2.x - b1.x;
      const dy = b2.y - b1.y;
      const dist = Math.hypot(dx, dy);
      
      if (dist < 2 * ballRadius) {
        // Separate overlapping balls
        const overlap = 2 * ballRadius - dist;
        if (dist > 0) {
          const separationX = (dx / dist) * overlap * 0.5;
          const separationY = (dy / dist) * overlap * 0.5;
          
          b1.x -= separationX;
          b1.y -= separationY;
          b2.x += separationX;
          b2.y += separationY;
        }

        // Calculate collision response
        const nx = dx / dist;
        const ny = dy / dist;
        const vRelativeX = b2.vx - b1.vx;
        const vRelativeY = b2.vy - b1.vy;
        const vRelativeNormal = vRelativeX * nx + vRelativeY * ny;
        
        // Only collide if balls are moving toward each other
        if (vRelativeNormal > 0) return;

        const restitution = 0.95;
        const j = -(1 + restitution) * vRelativeNormal;

        const impulseX = j * nx;
        const impulseY = j * ny;

        b1.vx -= impulseX * 0.5;
        b1.vy -= impulseY * 0.5;
        b2.vx += impulseX * 0.5;
        b2.vy += impulseY * 0.5;
      }
    }

    function animateShot() {
      const step = () => {
        let moving = false;
        
        // Check for and remove pocketed balls
        balls = balls.filter(b => {
          const isPocketed = pockets.some(p => Math.hypot(b.x - p.x, b.y - p.y) < p.r);
          if (isPocketed) {
            if (b.number === 0) {
              cueBallPocketedDuringShot = true;
            }
            return false; // Remove pocketed ball
          }
          return true; // Keep non-pocketed ball
        });
        
        // Update positions and apply friction
        balls.forEach(b => {
          const speed = Math.hypot(b.vx, b.vy);
          if (speed > MINIMUM_SPEED) {
            moving = true;
            
            // Update position
            b.x += b.vx;
            b.y += b.vy;
            
            // Apply appropriate friction based on speed
            const frictionMultiplier = speed < ROLLING_THRESHOLD ? 
              STATIC_FRICTION_MULTIPLIER : 1;
            
            const frictionFactor = 1 - (b.friction * frictionMultiplier);
            b.vx *= frictionFactor;
            b.vy *= frictionFactor;

            // Stop ball if moving very slowly
            if (Math.hypot(b.vx, b.vy) < MINIMUM_SPEED) {
              b.vx = 0;
              b.vy = 0;
            }

            // Boundary collisions with energy loss
            if (b.x < ballRadius) {
              b.x = ballRadius;
              b.vx *= -0.95;
            } else if (b.x > canvas.width - ballRadius) {
              b.x = canvas.width - ballRadius;
              b.vx *= -0.95;
            }
            
            if (b.y < ballRadius) {
              b.y = ballRadius;
              b.vy *= -0.95;
            } else if (b.y > canvas.height - ballRadius) {
              b.y = canvas.height - ballRadius;
              b.vy *= -0.95;
            }
          }
        });

        // Handle collisions with multiple iterations
        const iterations = 3;
        for (let iter = 0; iter < iterations; iter++) {
          for (let i = 0; i < balls.length; i++) {
            for (let j = i + 1; j < balls.length; j++) {
              collide(balls[i], balls[j]);
            }
          }
        }

        drawTable();
        
        if (moving) {
          requestAnimationFrame(step);
        } else {
          // All balls have stopped moving
          isMoving = false;
          document.getElementById('shootBtn').disabled = false;
          showGrid = false;
          showArm = false;

          if (cueBallPocketedDuringShot) {
            const newPos = findClearSpot(INITIAL_CUE_X, INITIAL_CUE_Y);
            balls.unshift({ // Add cue ball back to the beginning of the array
              x: newPos.x, y: newPos.y, vx: 0, vy: 0, mass: 1, number: 0, color: '#fff', friction: 0
            });
            cueBallPocketedDuringShot = false; // Reset the flag
          }
          
          drawTable(); // Re-draw table in case cue ball was re-added
          showSolution();
        }
      };
      
      requestAnimationFrame(step);
    }

    // --- Solution Animation Helper Functions ---

    function drawSolutionCueBallMarker(ball) {
        solCtx.strokeStyle = '#fff';
        solCtx.lineWidth = 1;
        solCtx.beginPath();
        solCtx.moveTo(ball.x - 10, ball.y); solCtx.lineTo(ball.x + 10, ball.y);
        solCtx.moveTo(ball.x, ball.y - 10); solCtx.lineTo(ball.x, ball.y + 10);
        solCtx.stroke();
    }

    function drawBallOnSolutionCanvas(ball) {
      solCtx.save();
      solCtx.beginPath(); solCtx.arc(ball.x, ball.y, ballRadius, 0, 2 * Math.PI);
      solCtx.fillStyle = ball.number === 0 ? ball.color : (ball.isStripe ? '#fff' : ball.color); // Simplified from original drawBall
      solCtx.fill();
      solCtx.strokeStyle = '#333'; solCtx.lineWidth = 1; solCtx.stroke(); // Darker stroke for solution canvas
      // Number/stripe details omitted for solution animation clarity, can be added if needed
      solCtx.restore();
    }

    function drawGridOnSolutionCanvas(originBall) {
      const spacing = 25;
      solCtx.save();
      solCtx.strokeStyle = 'rgba(255,255,255,0.15)'; solCtx.lineWidth = 1; // Dimmer grid for solution
      solCtx.font = '10px sans-serif'; solCtx.fillStyle = 'rgba(255,255,255,0.5)';

      for (let x = originBall.x % spacing; x < solCanvas.width; x += spacing) { solCtx.beginPath(); solCtx.moveTo(x, 0); solCtx.lineTo(x, solCanvas.height); solCtx.stroke(); }
      for (let y = originBall.y % spacing; y < solCanvas.height; y += spacing) { solCtx.beginPath(); solCtx.moveTo(0, y); solCtx.lineTo(solCanvas.width, y); solCtx.stroke(); }
      
      solCtx.strokeStyle = 'rgba(255,255,255,0.3)'; solCtx.lineWidth = 1.5; // Dimmer axis lines
      solCtx.beginPath(); solCtx.moveTo(originBall.x, 0); solCtx.lineTo(originBall.x, solCanvas.height); solCtx.stroke();
      solCtx.beginPath(); solCtx.moveTo(0, originBall.y); solCtx.lineTo(solCanvas.width, originBall.y); solCtx.stroke();
      // Grid labels omitted for solution animation clarity
      solCtx.restore();
    }

    function drawArmOnSolutionCanvas(originBall, angle, alpha, color = '#fff', length = 100) {
      solCtx.save();
      solCtx.globalAlpha = alpha;
      solCtx.strokeStyle = color; solCtx.fillStyle = color;
      solCtx.lineWidth = 3;
      
      const endX = originBall.x + Math.cos(angle) * length;
      const endY = originBall.y - Math.sin(angle) * length; // Y is inverted in canvas coordinates

      solCtx.beginPath(); solCtx.moveTo(originBall.x, originBall.y);
      solCtx.lineTo(endX, endY);
      solCtx.stroke();

      const headLen = 10; // Arrow head length
      const arrowAngle = Math.atan2(endY - originBall.y, endX - originBall.x); // Angle of the arm itself

      solCtx.beginPath();
      solCtx.moveTo(endX, endY);
      solCtx.lineTo(endX - headLen * Math.cos(arrowAngle - Math.PI / 6), endY - headLen * Math.sin(arrowAngle - Math.PI / 6));
      solCtx.lineTo(endX - headLen * Math.cos(arrowAngle + Math.PI / 6), endY - headLen * Math.sin(arrowAngle + Math.PI / 6));
      solCtx.closePath(); solCtx.fill();
    }

    function drawAngleArcAndText(shotData, angleToDraw) {
      const origin = { x: shotData.cueX, y: shotData.cueY };
      solCtx.save();
      solCtx.strokeStyle = '#ffff00'; solCtx.lineWidth = 2;
      solCtx.beginPath();
      // Ensure CCW arc: startAngle 0, endAngle -angle (because canvas Y is inverted)
      solCtx.arc(origin.x, origin.y, 40, 2*Math.PI -angleToDraw, 0, false); // Draw CCW
      solCtx.stroke();

      let angleText = "";
      const pi = Math.PI;
      const commonAnglesRad = {
          0: "0", [pi/6]: "π/6", [pi/4]: "π/4", [pi/3]: "π/3", [pi/2]: "π/2", [2*pi/3]: "2π/3",
          [3*pi/4]: "3π/4", [5*pi/6]: "5π/6", [pi]: "π", [7*pi/6]: "7π/6", [5*pi/4]: "5π/4",
          [4*pi/3]: "4π/3", [3*pi/2]: "3π/2", [5*pi/3]: "5π/3", [7*pi/4]: "7π/4", [11*pi/6]: "11π/6", [2*pi]: "2π"
      };
      let normalizedAngle = (angleToDraw % (2*pi) + (2*pi)) % (2*pi); // Normalize to 0-2PI

      if (shotData.unit === 'Radians') {
          let foundExact = false;
          for (const keyRad in commonAnglesRad) {
              if (Math.abs(normalizedAngle - parseFloat(keyRad)) < 0.001) {
                  angleText = commonAnglesRad[keyRad];
                  foundExact = true; break;
              }
          }
          if (!foundExact) angleText = normalizedAngle.toFixed(2) + " rad";
      } else {
          let angleDeg = normalizedAngle * 180 / pi;
          const commonAnglesDegLookup = {
              0:"0°",30:"30°",45:"45°",60:"60°",90:"90°",120:"120°",135:"135°",150:"150°",180:"180°",
              210:"210°",225:"225°",240:"240°",270:"270°",300:"300°",315:"315°",330:"330°",360:"360°"
          };
          let foundExactDeg = false;
          for(const degKey in commonAnglesDegLookup){
              if(Math.abs(angleDeg - parseFloat(degKey)) < 0.1){
                  angleText = commonAnglesDegLookup[degKey];
                  foundExactDeg = true; break;
              }
          }
          if (!foundExactDeg) angleText = angleDeg.toFixed(1) + "°";
      }

      solCtx.fillStyle = '#ffff00'; solCtx.font = 'bold 16px sans-serif';
      solCtx.textAlign = 'center'; solCtx.textBaseline = 'middle';
      const textRadius = 60;
      const textAngleDraw = angleToDraw / 2; // Midpoint of CCW arc
      solCtx.fillText(angleText, origin.x + textRadius * Math.cos(textAngleDraw), origin.y - textRadius * Math.sin(textAngleDraw)); // Invert Y for canvas
      solCtx.restore();
    }

    function animateCueBallReturn(cueBallInitialWorldPos, targetPos, duration, callback) {
        let startX = cueBallInitialWorldPos.x;
        let startY = cueBallInitialWorldPos.y;
        let startTime = null;

        function step(timestamp) {
            if (!startTime) startTime = timestamp;
            let progress = Math.min((timestamp - startTime) / duration, 1);
            let currentX = startX + (targetPos.x - startX) * progress;
            let currentY = startY + (targetPos.y - startY) * progress;

            solCtx.clearRect(0, 0, solCanvas.width, solCanvas.height);
            drawBallOnSolutionCanvas({ x: currentX, y: currentY, number: 0, color: '#fff' });

            if (progress < 1) requestAnimationFrame(step);
            else callback({x: currentX, y: currentY});
        }
        requestAnimationFrame(step);
    }

    function animateGridFadeIn(cueBallPos, duration, callback) {
        let startTime = null;
        function step(timestamp) {
            if (!startTime) startTime = timestamp;
            let progress = Math.min((timestamp - startTime) / duration, 1);

            solCtx.clearRect(0, 0, solCanvas.width, solCanvas.height);
            drawBallOnSolutionCanvas(cueBallPos); // Keep cue ball visible
            solCtx.globalAlpha = progress;
            drawGridOnSolutionCanvas(cueBallPos);
            solCtx.globalAlpha = 1.0;

            if (progress < 1) requestAnimationFrame(step);
            else callback();
        }
        requestAnimationFrame(step);
    }
    
    function getAlternateAngle(theta, ratioType, originalValue) {
        const pi = Math.PI;
        let refAngle = 0; // Reference angle in Q1 [0, pi/2]
        let normalizedTheta = (theta % (2*pi) + (2*pi)) % (2*pi);

        if (normalizedTheta <= pi/2) refAngle = normalizedTheta;
        else if (normalizedTheta <= pi) refAngle = pi - normalizedTheta;
        else if (normalizedTheta <= 3*pi/2) refAngle = normalizedTheta - pi;
        else refAngle = 2*pi - normalizedTheta;

        let altAngle;
        // Determine the other angle that gives the same *signed* trig value
        if (/sin|csc/.test(ratioType)) { // sin is positive in Q1, Q2; negative in Q3, Q4
            altAngle = pi - normalizedTheta;
        } else if (/cos|sec/.test(ratioType)) { // cos is positive in Q1, Q4; negative in Q2, Q3
            altAngle = (originalValue >= 0 && (normalizedTheta > pi/2 && normalizedTheta < 3*pi/2)) || (originalValue < 0 && (normalizedTheta < pi/2 || normalizedTheta > 3*pi/2)) ? 2*pi - normalizedTheta : -normalizedTheta;
             // This needs more robust handling for cos, especially around 0 and PI
            altAngle = 2*pi - normalizedTheta; // Simpler: other angle with same cos value
            if (Math.abs(Math.cos(altAngle) - Math.cos(normalizedTheta)) > 0.001) altAngle = -normalizedTheta;


        } else { // tan|cot positive in Q1, Q3; negative in Q2, Q4
            altAngle = normalizedTheta + pi;
        }
        return (altAngle % (2*pi) + (2*pi)) % (2*pi); // Normalize
    }


    function animateAngleSolution(shotData, cueBallPos, durationPerStep, callback) {
        const { actualTheta, ratioType, ratioValueNumeric } = shotData;
        let otherTheta = getAlternateAngle(actualTheta, ratioType, ratioValueNumeric);
    
        // Ensure otherTheta is distinct enough for animation, if not, make it same as actualTheta
        if (Math.abs(otherTheta - actualTheta) < 0.01 || Math.abs(otherTheta - actualTheta - 2*Math.PI) < 0.01 || Math.abs(otherTheta - actualTheta + 2*Math.PI) < 0.01) {
            otherTheta = actualTheta;
        }
        
        let animState = 0; // 0: show actual, 1: show other, 2: fade other, 3: final display
        let startTime = null;
        let armAngle = 0;
        let arcProgress = 0;
    
        function step(timestamp) {
            if (!startTime) startTime = timestamp;
            let elapsed = timestamp - startTime;
            let progress = Math.min(elapsed / durationPerStep, 1);
    
            solCtx.clearRect(0, 0, solCanvas.width, solCanvas.height);
            drawBallOnSolutionCanvas(cueBallPos);
            drawGridOnSolutionCanvas(cueBallPos);
    
            switch (animState) {
                case 0: // Show actualTheta arm
                    armAngle = actualTheta * progress;
                    drawArmOnSolutionCanvas(cueBallPos, armAngle, 1.0, '#00ff00'); // Green for chosen
                    if (progress >= 1) { animState = 1; startTime = timestamp; progress = 0; armAngle = actualTheta; }
                    break;
                case 1: // Also show otherTheta arm (if different)
                    drawArmOnSolutionCanvas(cueBallPos, actualTheta, 1.0, '#00ff00');
                    if (otherTheta !== actualTheta) {
                        armAngle = actualTheta + (otherTheta - actualTheta) * progress;
                        drawArmOnSolutionCanvas(cueBallPos, armAngle, progress, '#ff0000'); // Red for other
                    }
                    if (progress >= 1) { animState = 2; startTime = timestamp; progress = 0; armAngle = otherTheta; }
                    break;
                case 2: // Fade out otherTheta arm
                    drawArmOnSolutionCanvas(cueBallPos, actualTheta, 1.0, '#00ff00');
                    if (otherTheta !== actualTheta) {
                        armAngle = otherTheta;
                        drawArmOnSolutionCanvas(cueBallPos, armAngle, 1.0 - progress, '#ff0000');
                    }
                    if (progress >= 1) { animState = 3; startTime = timestamp; progress = 0; arcProgress = 0;}
                    break;
                case 3: // Final display: chosen arm, arc, text
                    drawArmOnSolutionCanvas(cueBallPos, actualTheta, 1.0, '#00ff00');
                    // Call the global, correct drawAngleArcAndText function
                    if (progress >= 1) { // Ensure this runs once the fade-out is complete
                        drawAngleArcAndText(shotData, actualTheta); // Use the global function
                        callback(); // Animation sequence finished
                        return;
                    }
                    break;
            }
            requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
    }
    
    function showSolution() {
      document.getElementById('solutionOverlay').style.display = 'block';
      solCtx.clearRect(0, 0, solCanvas.width, solCanvas.height);
      document.getElementById('solutionText').innerHTML = ''; // Clear previous text

      if (!animatedSolutionsEnabled || !initialShotData.cueX) { // Fallback if no initial data
        document.getElementById('solutionText').innerHTML = '<p>Shot complete. Click Continue.</p>';
        const cueBall = balls.find(b => b.number === 0) || { x: INITIAL_CUE_X, y: INITIAL_CUE_Y };
        drawSolutionCueBallMarker(cueBall);
        return;
      }

      // Store non-cue balls and find current cue ball position for animation start
      nonCueBallsForSolution = balls.filter(b => b.number !== 0).map(b => ({ ...b }));
      let cueBallForAnimStart = balls.find(b => b.number === 0);
      if (!cueBallForAnimStart) { // Should be present due to prior logic
          cueBallForAnimStart = { x: initialShotData.cueX, y: initialShotData.cueY, number: 0, color: '#fff' }; // Fallback
      }
      
      const animCuePos = { x: cueBallForAnimStart.x, y: cueBallForAnimStart.y, number: 0, color: '#fff' };
      const targetCuePos = { x: initialShotData.cueX, y: initialShotData.cueY };

      animateCueBallReturn(animCuePos, targetCuePos, 700, (returnedCuePos) => {
        animateGridFadeIn(returnedCuePos, 500, () => {
          animateAngleSolution(initialShotData, returnedCuePos, 1000, () => {
            document.getElementById('solutionText').innerHTML = '<p>Analysis complete. Click Continue.</p>';
          });
        });
      });
    }

    function hideSolution() {
      document.getElementById('solutionOverlay').style.display = 'none';
      
      if (nonCueBallsForSolution.length > 0) {
        const cueBall = balls.find(b => b.number === 0); // Current cue ball (might be newly placed)
        balls = cueBall ? [cueBall, ...nonCueBallsForSolution] : [...nonCueBallsForSolution];
        nonCueBallsForSolution = [];
      }
      // If cue ball was pocketed and re-added, it's already in 'balls'.
      // If not, it's also in 'balls'.
      // The main concern is restoring the other balls.

      nextTurn();
      drawTable(); // Will draw the current state of 'balls'
    }

    function hideError() {
      document.getElementById('errorOverlay').style.display = 'none';
      // Potentially reset something or just allow next turn
      nextTurn();
      drawTable();
    }

    function nextTurn() {
      currentPlayer = currentPlayer === 1 ? 2 : 1;
      document.getElementById('playerLabel').textContent = currentPlayer;
      // Reset any shot-specific UI elements if needed here
    }
  </script>
</body>
</html>